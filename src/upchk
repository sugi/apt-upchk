#!/usr/bin/perl
# -*- cperl -*-

#
# simple apt update checker.
#
# author: Tatsuki Sugiura <sugi@nemui.org>
# license: GPL
#

use strict;
use warnings;
use lib '/usr/share/apt-upchk/lib';
use AptUpchk;
use Getopt::Long;
Getopt::Long::Configure("gnu_getopt");
use Sys::Hostname;
use IO::File;

my $statfh = undef;
my $exitcode = 0;

$ENV{LANG} = "C";
$ENV{LC_ALL} = "C";

our %opt = (config      => "/etc/apt-upchk/upchk.conf",
	    "no-update" => 0,
	    "workroot"  => "/var/lib/apt-upchk/workroot",
	    "apt-get"   => "/usr/share/apt-upchk/scripts/apt-simulate",
	   );

if ( -r $opt{config} ) {
    do $opt{config};
    die "Error in config file: $@\n" if $@;
}

my %cmdopt;
GetOptions(\%cmdopt,
	   "no-update|n",
	   "apt-get=s" ) or die "\n";

foreach my $o (keys %cmdopt) {
    $opt{$o} = $cmdopt{$o};
}

unless ( -x $opt{"apt-get"} ) {
    die "Can't exec apt-get($opt{'apt-get'}): $!\n";
}

my $update_out = "";
my $update_ret = 0;

unless ( $opt{"no-update"} ) {
    $update_out = `$opt{"apt-get"} -qq update 2>&1`;
    $update_ret = $? >> 8;
}

my @upgrade_out = split(/\n/, `$opt{"apt-get"} -u -s dist-upgrade 2>&1`);
my $upgrade_ret = $?;

# output
{
    print qq[<?xml version="1.0" encoding="US-ASCII"?>\n],
	"<apt-upchk-report>\n",
	"<version>$AptUpchk::VERSION</version>\n",
        "<hostname>", hostname(), "</hostname>\n",
	"<unixtime>", time(), "</unixtime>\n",
	"<update-command><exitcode>${update_ret}</exitcode>\n",
	"<output><![CDATA[", $update_out,
	"]]></output></update-command>\n";

    {
	my $kept_p = 0;
	my $kept_lines = "";
	foreach ( @upgrade_out ) {
	    if ($kept_p) {
		if (/^ /) {
		    $kept_lines .= " $_ ";
		} else {
		    $kept_p = 0;
		}
	    }
	    elsif (/^The following packages have been kept back/){
		$kept_p = 1;
		$exitcode = 50;
	    }
	}
	foreach (split /\s+/, $kept_lines) {
	    $_ eq "" and next;
	    my $pstat = &get_new_pkg_stat($_);
	    print "<keptbackpkg>\n",
		"<name>$_</name>\n",
		"<current-version>", &get_installed_ver($_), "</current-version>\n",
		"<new-version>", $pstat->{"new-version"}, "</new-version>\n",
		"<release>", $pstat->{release}, "</release>\n",
		"</keptbackpkg>\n";
	}
    }

    my @packages = grep(/^Inst /i, @upgrade_out);
    $exitcode = 100 if @packages;
    foreach (@packages) {
	if ( /^Inst (\S+)\s+(?:\[(.*?)\])?\s*\((\S+)(?:\s+(.+?))?\)/ ) {
	    print "<updatepkg>\n",
		"<name>$1</name>\n",
		"<current-version>",
	       	$2 || &get_installed_ver($1),
	       	"</current-version>\n",
		"<new-version>$3</new-version>\n";
	    print "<release>$4</release>\n" if ($4);
	    print "</updatepkg>\n"
	} else {
	    warn "abnormal line was detected: $_\n";
	}
    }

    print "</apt-upchk-report>\n";
}

exit($exitcode);

## utils
sub get_installed_ver($) {
    my $pkg = shift;
    my $version = undef;
    unless ( $statfh ) {
	$statfh = IO::File->new("/var/lib/dpkg/status");
    }

    my ($line);
    seek($statfh, 0, 0);
  LOOP:
    while ( $line = <$statfh> ) {
	if ($line =~ /^Package:\s+${pkg}$/) {
	    while ( $line = <$statfh> ) {
		if ($line =~ /^Version:\s+(.*)$/) {
		    $version = $1;
		    last LOOP;
		} elsif ( $line eq "\n" ) {
		    last LOOP;
		}
	    }
	}
    }
    $version;
}

sub get_new_pkg_stat ($) {
    my $pkg = shift;
    my $ret = {};
    my $line = "";
    open(CHE, "apt-cache -o Dir='$opt{workroot}' showpkg $pkg|");
    $line = <CHE> while $line !~ /^Versions:/;
    $line = <CHE>;
    close(CHE);
    ($ret->{"new-version"}) = ($line =~ /^(\d[\d.-]*-\d+)/);
    my @packages = ($line =~ /\(([^()]+)\)/g);
    foreach my $p (@packages) {
	my $r = $p;
	$r =~ s/_Packages$/_Release/;
	if ( -f $r ) {
	    my %rel;
	    my $rfh = IO::File->new($r);
	    my $rl;
	    while ($rl = <$rfh>) {
		$rl =~ /^([^:]+):\s+(.*)/;
		$rel{$1} = $2;
	    }
	    $rfh->close;
	    $ret->{release} = defined($rel{Version}) ?
		"$rel{Label}:$rel{Version}/$rel{Archive}" :
		    "$rel{Label}:$rel{Archive}";
	    last;
	}
	$ret->{release} = ($p =~ m|.+/([^_]+)|);
    }
    $ret;
}
