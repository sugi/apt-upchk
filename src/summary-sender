#!/usr/bin/perl
# -*- cperl -*-

package AptUpchk::Notify;
our $SOCK_PATH = "/tmp/apt-upchk-summary";
our %Conf = (config  => "/etc/apt-upchk/summary.conf",
	     timeout => 600,
	     mailto  => ["root"],
	    );

sub parseconfig {
    if ( -r $Conf{config} ) {
	do $Conf{config};
	die "Error in config file: $@\n" if $@;
    }
}


package AptUpchk::Notify::Daemon;
use strict;
use warnings;
use Carp;
use IO::File;
use IO::Seekable;
use IO::Socket::UNIX;
use XML::DOM;
use XML::XQL;
use XML::XQL::DOM;
use lib "/usr/share/apt-upchk/scripts";
require 'report';

sub new {
    my $class = shift;
    my $self  = { need_send => 0, temp => undef };
    AptUpchk::Notify::parseconfig;
    bless $self, $class;
}

sub _cleanup {
    unlink($SOCK_PATH);
}

sub DESTROY {
    my $self = shift;
    $self->{temp}->close if $self->{temp};
    _cleanup;
}

sub set_timer {
    my $self = shift;
    $self->_log("timer reset\n");
    $SIG{ALRM} = sub { $self->send_report; _cleanup; exit(0); };
    alarm 0;
    alarm $Conf{timeout};
}

sub fork {
    my $self = shift;
    my $pid = fork;
    return(1) if $pid;
    close(STDIN);
    #close(STDOUT);
    #close(STDERR);
    $self->_log("forked. pid=$$\n");
    $self->run;
}

sub run {
    my $self = shift;
    $self->acceptloop;
}

sub listen {
    my $self = shift;
    $self->_log("opeing socket...");
    my $s = IO::Socket::UNIX->new(Local => $SOCK_PATH);
    $self->_log("done\n");
    unless ($s) {
	croak "can't open socket: $!\n";
    }
    $SIG{INT} = $SIG{TERM} = $SIG{QUIT} = sub { _cleanup; };
    $self->{sock} = $s;
    $self->{sock}->listen;
    $self;
}

sub acceptloop {
    my $self = shift;
    $self->listen;
    $self->_log("waiting client...\n");
    $self->set_timer;
    my $peer;
    while ( $peer = $self->{sock}->accept ) {
	$self->set_timer;
	$self->_log("connected. reading data\n");
	local($/);
	undef $/;
	$self->write_report(XML::DOM::Parser->new->parse(<$peer>));
    }
}

sub gettemp {
    my $self = shift;
    unless ($self->{temp}) {
	$self->{temp} = IO::File->new_tmpfile;
    }
    $self->{temp}
}

sub write_report($) {
    my $self = shift;
    my $doc  = shift;

    return 1 unless $doc->xql("//updatepkg") || $doc->xql("//keptbackpkg");

    $self->_log("write donw report...\n");
    my $temp = $self->gettemp;

    print $temp "======== Report for ",
	[$doc->xql("/apt-upchk-report/hostname")]->[0]->getFirstChild->getData,
	" ========\n";
    my $rep = AptUpchk::Report::SingleHost->new(doc => $doc, output => $temp);
    $rep->report_update_err   and print $temp "\n";
    $rep->report_security_pkg and print $temp "\n";
    $rep->report_update_pkg   and print $temp "\n";
    $rep->report_hold_pkg     and print $temp "\n";
    $temp->sync;
    $self->{need_send} = 1;
}

sub send_report {
    my $self = shift;
    return(1) unless $self->{need_send};
    $self->_log("sending report...");

    my $temp = $self->gettemp;
    my $mail = IO::File->new("| /usr/sbin/sendmail ". join(" ",  @{$Conf{mailto}}));
    print $mail "Subject: Updated Package Report\n",
	"X-Sender: apt-upchk-summary\n",
	"To: ", join(", ", @{$Conf{mailto}}), "\n", "\n";
    $temp->sync;
    $temp->seek(0, 0);
    my $line;
    while ( $line = <$temp> ){
	print $mail "  " if $line !~ /^====/; # HMMMMMMMMMM... FIXME!! STUPID!!
	print $mail $line;
    }
    $self->_log("done\n");
}

sub _log {
    return 1;
    my $self = shift;
    print @_;
}

#########################
package AptUpchk::Notify::Client;

use strict;
use warnings;
use Carp;
use IO::Socket::UNIX;

sub new {
    my $class = shift;
    my $self  = { @_ };
    bless $self, $class;
}

sub _start_daemon {
    #AptUpchk::Notify::Daemon->new->fork;
    system("$0 daemon");
    sleep(5);
}

sub connect {
    my $self = shift;
    {
	alarm 30;
	local $SIG{ALRM} = sub { croak "timeout. can't find daemon socket.\n" };
	while (! (-e $SOCK_PATH) ) {
	    &_start_daemon();
	}
	alarm 0;
    }
    my $sock;

    foreach (1..3) {
	$sock = IO::Socket::UNIX->new($SOCK_PATH);
	$sock ? last : carp("can't connect to daemon socket. retrying...\n");
	unlink($SOCK_PATH);
	&_start_daemon();
    }
    croak "gave up to connect daemon\n" unless $sock;
    $self->{sock} = $sock;
}

sub get_sock {
    my $self = shift;
    $self->connect unless exists($self->{sock}) && $self->{sock};
    $self->{sock};
}

sub senddoc {
    my $self = shift;
    my $doc  = shift;
    my $sock = $self->get_sock;
    if ( ref($doc) eq "IO::File" ) {
	my $line;
	while ( $line = <$doc> ) {
	    print $sock $line;
	}
    } else {
	print $sock $doc;
    }
}


#########################
package main;
use strict;
use warnings;

if (__FILE__ eq $0) {
#    use XML::DOM;
#    my $dom = XML::DOM::Parser->new->parse(*STDIN);
#    my $rep = AptUpchk::Report::SingleHost->new($dom);
#    $rep->report;
#    my $d = AptUpchk::Notify::Daemon->new->fork;

    if (@ARGV && $ARGV[0] eq "daemon") {
	if (fork) {
	    exit(0);
	} else {
	    AptUpchk::Notify::Daemon->new->run;
	}
    } else {
	use IO::File;
	my $infh = IO::File->new("-");
	my $report = "";
	my $header = 1;
	while ( <$infh> ) {
	    /^<\?xml/ and $header = 0;
	    next if $header;
	    $report .= $_;
	}
	AptUpchk::Notify::Client->new->senddoc($report);
    }
}

